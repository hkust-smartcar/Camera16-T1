/*
 * Memory Spaces Definitions.
 *
 * Need modifying for a specific board. 
 *
 * The values below can be addressed in further linker scripts
 * using functions like 'ORIGIN(RAM)' or 'LENGTH(RAM)'.
 */

MEMORY
{
  /* 
   * Unusual Freescale KL family configuration, one quarter of the 
   * entire RAM is below 0x2000000, three quarters above.
   * The RAM size must be exactly the size of the physical memory,  
   * not more, not less.
   */
  RAM (xrw) : ORIGIN = 0x20000000 - (32K / 4), LENGTH = 32K
  INTERRUPTS (rx) : ORIGIN = 0x00000000, LENGTH = 0x400
  CFMPROTROM (rx) : ORIGIN = 0x00000400, LENGTH = 0x10
  FLASH (rx) : ORIGIN = 0x00000410, LENGTH = 256K - 0x00000410

}
/* 
 * The entry point is informative, for debuggers and simulators,
 * since the Cortex-M vector points to it anyway.
 */
ENTRY(_start)

/*
 * The '__stack' definition is required by crt0, do not remove it.
 */
__stack = ORIGIN(RAM) + LENGTH(RAM);

_estack = __stack; 	/* STM specific definition */

/*
 * Default stack sizes.
 * These are used by the startup in order to allocate stacks 
 * for the different modes.
 */

__Main_Stack_Size = 1024 ;

PROVIDE ( _Main_Stack_Size = __Main_Stack_Size ) ;

__Main_Stack_Limit = __stack  - __Main_Stack_Size ;

/*"PROVIDE" allows to easily override these values from an object file or the command line. */
PROVIDE ( _Main_Stack_Limit = __Main_Stack_Limit ) ;

/*
 * There will be a link error if there is not this amount of 
 * RAM free at the end. 
 */
_Minimum_Stack_Size = 256 ;

/*
 * Default heap definitions.
 * The heap start immediately after the last statically allocated 
 * .sbss/.noinit section, and extends up to the main stack limit.
 */
PROVIDE ( _Heap_Begin = _end_noinit ) ;
PROVIDE ( _Heap_Limit = __stack - __Main_Stack_Size ) ;

/* Sections Definitions */

SECTIONS
{
    /*
     * For Cortex-M devices, the beginning of the startup code is stored in
     * the .isr_vector section, which goes to FLASH 
     */
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector))     	/* Interrupt vectors */   
        . = ALIGN(4);
    } >INTERRUPTS
    
    .cfmprotrom :
    {
        . = ALIGN(4);
		KEEP(*(.cfmconfig))			/* Freescale configuration words */     
        . = ALIGN(4);
    } >CFMPROTROM
    
    .after_vectors :
    {
        . = ALIGN(4);
		KEEP(*(.after_vectors .after_vectors.*))	/* Startup code and ISR */
        . = ALIGN(4);
    } >FLASH

    
    /*
     * The program code is stored in the .text section, 
     * which goes to FLASH.
     */
    .text :
    {
        . = ALIGN(4);
	    
        *(.text .text.*)			/* all remaining code */
        *(.rodata .rodata.*) 		/* read-only data (constants) */
        *(vtable)					/* C++ virtual tables */
		KEEP(*(.eh_frame*))
		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
        *(.glue_7)
        *(.glue_7t)
        *(.eh_frame)

	    KEEP (*(.init))
	    KEEP (*(.fini))
	    
	    . = ALIGN(4);
	    _etext = .;        /* define a global symbols at end of code */	        

    } >FLASH

	/* 
     * This address is used by the startup code to 
     * initialise the .data section.
     */
    _sidata = _etext;

	.ARM.extab   : { 
		*(.ARM.extab* .gnu.linkonce.armextab.*) 
	} > FLASH
	
    .ARM : {
	    __exidx_start = .;
	      *(.ARM.exidx*)
	      __exidx_end = .;
	} > FLASH
	
	.ctors :
	{
		__CTOR_LIST__ = .;
		/* gcc uses crtbegin.o to find the start of
		   the constructors, so we make sure it is
		   first.  Because this is a wildcard, it
		   doesn't matter if the user does not
		   actually link against crtbegin.o; the
		   linker won't look for a file to match a
		   wildcard.  The wildcard also means that it
		   doesn't matter which directory crtbegin.o
		   is in.  */
		KEEP (*crtbegin.o(.ctors))
		/* We don't want to include the .ctor section from
		   from the crtend.o file until after the sorted ctors.
		   The .ctor section from the crtend file contains the
		   end of ctors marker and it must be last */
		KEEP (*(EXCLUDE_FILE (*crtend.o ) .ctors))
		KEEP (*(SORT(.ctors.*)))
		KEEP (*(.ctors))
		__CTOR_END__ = .;
	} > FLASH
	
	.dtors :
	{
	    __DTOR_LIST__ = .;
	    KEEP (*crtbegin.o(.dtors))
	    KEEP (*(EXCLUDE_FILE (*crtend.o ) .dtors))
	    KEEP (*(SORT(.dtors.*)))
	    KEEP (*(.dtors))
	    __DTOR_END__ = .;
	} > FLASH

	.preinit_array     :
	{
	    PROVIDE_HIDDEN (__preinit_array_start = .);
	    KEEP (*(.preinit_array*))
	    PROVIDE_HIDDEN (__preinit_array_end = .);
	} > FLASH
	
	.init_array :
	{
	    PROVIDE_HIDDEN (__init_array_start = .);
	    KEEP (*(SORT(.init_array.*)))
	    KEEP (*(.init_array*))
	    PROVIDE_HIDDEN (__init_array_end = .);
	} > FLASH

	.fini_array :
	{
	    PROVIDE_HIDDEN (__fini_array_start = .);
	    KEEP (*(SORT(.fini_array.*)))
	    KEEP (*(.fini_array*))
	    PROVIDE_HIDDEN (__fini_array_end = .);
	
	   	___ROM_AT = .;
	} > FLASH
	
	/* Initialized data sections goes into RAM, load LMA copy after code */
	.data : AT(___ROM_AT)
	{
		. = ALIGN(4);
		_sdata = .;        /* create a global symbol at data start */
		*(.data)           /* .data sections */
		*(.data*)          /* .data* sections */
		
		. = ALIGN(4);
		/* # Additional data content defined by components END */
		
		_edata = .;        /* define a global symbol at data end */
		
		. = ALIGN(0x200);
		KEEP(*(.vectortableram)) /* vector table in ram */
	} > RAM
	
	/*
     * The uninitialised data section. NOLOAD is used to avoid
     * the "section `.bss' type changed to PROGBITS" warning
     */
    .bss (NOLOAD) :
    {
	    . = ALIGN(4);
        __bss_start__ = .;     	/* standard newlib definition */
        _sbss = .;              /* STM specific definition */
        *(.bss_begin .bss_begin.*)

        *(.bss .bss.*)
        *(COMMON)
        
        *(.bss_end .bss_end.*)
	    . = ALIGN(4);
        __bss_end__ = .;        /* standard newlib definition */
        _ebss = . ;             /* STM specific definition */
    } >RAM
    
    .noinit (NOLOAD) :
    {
	    . = ALIGN(4);
        _noinit = .;
        
        *(.noinit .noinit.*) 
        
         . = ALIGN(4) ;
        _end_noinit = .;   
    } > RAM
    
    /* Mandatory to be word aligned, _sbrk assumes this */
    PROVIDE ( end = _end_noinit ); /* was _ebss */
    PROVIDE ( _end = _end_noinit );
    PROVIDE ( __end = _end_noinit );
    PROVIDE ( __end__ = _end_noinit );
    
    /*
     * Used for validation only, do not allocate anything here!
     *
     * This is just to check that there is enough RAM left for the Main
     * stack. It should generate an error if it's full.
     */
    ._check_stack :
    {
	    . = ALIGN(4);
        
        . = . + _Minimum_Stack_Size ;
        
	    . = ALIGN(4);
    } >RAM

}